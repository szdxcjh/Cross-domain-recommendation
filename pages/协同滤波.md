---
title: 协同滤波
---

## 协同滤波Collaborative Filtering (CF)是推荐系统常用的模型；
## 既然是推荐，一定设计人和物两个方面，因此 CF 分为基于用户的CF和基于item的CF。

一、基于用户的CF计算用户之间的相似性，并且推荐相互之间物品的差集，这里的特征向量是item 列表向量；

二、基于item的CF主要是计算item之间的相似性，这里的特征向量是用户拥有情况向量，对相似性比较大的特征向量A,B当中的差集用户进行相互推荐。
## 概念：协同过滤一般是在海量的用户中发掘出一小部分和你品位（偏好）比较类似的，在协同过滤中，这些用户成为邻居，然后根据他们喜欢的其他东西组织成一个排序的目录作为推荐给你。
## 核心的问题：
如何确定一个用户是不是和你有相似的品位？
如何将邻居们的喜好组织成一个排序的目录？
## 步骤：
    1.收集用户偏好
    2.找到相似的用户或物品
    3.计算推荐
## 1.收集用户偏好
### 基本上有以下两种方式：
### 将不同的行为分组 
一般可以分为“查看”和“购买”等等，然后基于不同的行为，计算不同的用户 / 物品相似度。类似于当当网或者 Amazon 给出的“购买了该图书的人还购买了 ...”，“查看了图书的人还查看了 ...”

加权操作 
根据不同行为反映用户喜好的程度将它们进行加权，得到用户对于物品的总体喜好。一般来说，显式的用户反馈比隐式的权值大，但比较稀疏，毕竟进行显示反馈的用户是少数；同时相对于“查看”，“购买”行为反映用户喜好的程度更大，但这也因应用而异。
### 收集了用户行为数据，我们还需要对数据进行一定的预处理，其中最核心的工作就是：减噪和归一化。
    减噪 
用户行为数据是用户在使用应用过程中产生的，它可能存在大量的噪音和用户的误操作，我们可以通过经典的数据挖掘算法过滤掉行为数据中的噪音，这样可以是我们的分析更加精确。
    归一化 
在计算用户对物品的喜好程度时，可能需要对不同的行为数据进行加权。不同行为的数据取值可能相差很大，比如，用户的查看数据必然比购买数据大的多，如何将各个行为的数据统一在一个相同的取值范围中，从而使得加权求和得到的总体喜好更加精确，就需要我们进行归一化处理。最简单的归一化处理，就是将各类数据除以此类中的最大值，以保证归一化后的数据取值在 [0,1] 范围中。
## 2、找到相似的用户或物品
### 当已经对用户行为进行分析得到用户喜好后，我们可以根据用户喜好计算相似用户和物品，然后基于相似用户或者物品进行推荐，这就是最典型的 CF 的两个分支：基于用户的 CF 和基于物品的 CF。这两种方法都需要计算**相似度**，下面我们先看看最基本的几种计算相似度的方法。
### 1.欧几里得距离（不说了）
### 2皮尔逊相关系数（Pearson Correlation Coefficient）
皮尔逊相关系数一般用于计算两个定距变量间联系的紧密程度，它的取值在 [-1，+1] 之间。 sx, sy是 x 和 y 的样品标准偏差。
### 3.Cosine 相似度（Cosine Similarity）
### 4.Tanimoto 系数
### 5.相似邻居计算：类似于KNN，容易受到极端值影响。
### 6.基于相似度门槛的邻居：Threshold-based neighborhoods
    与计算固定数量的邻居的原则不同，基于相似度门槛的邻居计算是对邻居的远近进行最大值的限制，落在以当前点为中心，距离为 K 的区域中的所有点都作为当前点的邻居，这种方法计算得到的邻居个数不确定，但相似度不会出现较大的误差。
## 3.计算推荐
### 如何基于这些信息为用户进行推荐呢？
### 1.基于用户的 CF（User CF）
    基于用户的 CF 的基本思想相当简单，基于用户对物品的偏好找到相邻邻居用户，然后将邻居用户喜欢的推荐给当前用户。计算上，就是将一个用户对所有物品的偏好作为一个向量来计算用户之间的相似度，找到 K 邻居后，根据邻居的相似度权重以及他们对物品的偏好，预测当前用户没有偏好的未涉及物品，计算得到一个排序的物品列表作为推荐。
### 2.基于物品的 CF（Item CF）
    基于物品的 CF 的原理和基于用户的 CF 类似，只是在计算邻居时采用物品本身，而不是从用户的角度，即基于用户对物品的偏好找到相似的物品，然后根据用户的历史偏好，推荐相似的物品给他。从计算的角度看，就是将所有用户对某个物品的偏好作为一个向量来计算物品之间的相似度，得到物品的相似物品后，根据用户历史的偏好预测当前用户还没有表示偏好的物品，计算得到一个排序的物品列表作为推荐。
## 研究推荐引擎的学者们在相同的数据集合上分别用 User CF 和 Item CF 计算推荐结果，发现推荐列表中，只有 50% 是一样的，还有 50% 完全不同。但是这两个算法确有相似的精度，所以可以说，这两个算法是很互补的。
## 第一种度量方法是从单个用户的角度度量，就是说给定一个用户，查看系统给出的推荐列表是否多样，也就是要比较推荐列表中的物品之间两两的相似度，不难想到，对这种度量方法，Item CF 的多样性显然不如 User CF 的好，因为 Item CF 的推荐就是和以前看的东西最相似的。
第二种度量方法是考虑系统的多样性，也被称为**覆盖率 (Coverage)**，它是指一个推荐系统是否能够提供给所有用户丰富的选择。在这种指标下，Item CF 的多样性要远远好于 User CF, 因为 **User CF 总是倾向于推荐热门的**，从另一个侧面看，也就是说，**Item CF** 的推荐有很好的新颖性，**很擅长推荐长尾里的物品**。所以，尽管大多数情况，Item CF 的精度略小于 User CF， 但如果考虑多样性，Item CF 却比 User CF 好很多。
