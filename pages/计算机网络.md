---
title: 计算机网络
---

## 1.OSI七层（或其他）参考模型
## ![2021_05_28_image.png](https://cdn.logseq.com/%2F1e5b0e5f-d368-4a5d-86eb-09a690ee15d7d0d6e7a0-0d12-4612-bb2f-15aee417044f2021_05_28_image.png?Expires=4775767112&Signature=RYnXru6JccQ6RYv4bO5x4hCfugIiHwy9u6YMnbs40gFMKY~FLLW9HH3E~K-kZrUM6oZ1DwkB3d87ktlfeHnj0cEuZeXZwuotE90bxzwSqR5FkWIHv1esFn2tf99cESw67fY6TVzsUzN7zoFqtYi3NqsRfP~6e72GNWHs7UN-zRBxWUHS7pSrJ9ZAm39rvXBW66Vcsdm2aEvwFefyto-YpH6TP3f7BaGVFZxdtBkkYAaQX4LRT7K0Ky8uwE7EFugAsOJFBRSZjZYpaLAnxZRfGp~-bG~yeHqxC0kn3Ntl3pN3Dal4ei3GGJkEZoVSow4c5islR~Hmi324fKrQzB8Pmw__&Key-Pair-Id=APKAJE5CCD6X7MP6PTEA)
## OSI 模型全称为开放式通信系统互连参考模型，是国际标准化组织 ( ISO ) 提出的一个试图使各种计算机在世界范围内互连为网络的标准框架。 OSI 将计算机网络体系结构划分为七层，每一层实现各自的功能和协议，并完成与相邻层的接口通信。OSI 的服务定义详细说明了各层所提供的服务。某一层的服务就是该层及其下各层的一种能力，它通过接口提供给更高一层。各层所提供的服务与这些服务是怎么实现的无关。
① 应用层

应用层位于 OSI 参考模型的第七层，其作用是通过应用程序间的交互来完成特定的网络应用。该层协议定义了应用进程之间的交互规则，通过不同的应用层协议为不同的网络应用提供服务。例如域名系统 DNS，支持万维网应用的 HTTP 协议，电子邮件系统采用的 SMTP 协议等。在应用层交互的数据单元我们称之为报文。
② 表示层

表示层的作用是使通信的应用程序能够解释交换数据的含义，其位于 OSI 参考模型的第六层，向上为应用层提供服务，向下接收来自会话层的服务。该层提供的服务主要包括数据压缩，数据加密以及数据描述。这使得应用程序不必担心在各台计算机中表示和存储的内部格式差异。

③ 会话层

会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法。

④ 传输层

传输层的主要任务是为两台主机进程之间的通信提供服务。应用程序利用该服务传送应用层报文。该服务并不针对某一特定的应用，多种应用可以使用同一个传输层服务。由于一台主机可同时运行多个线程，因此传输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面传输层的服务，分用和复用相反，是传输层把收到的信息分别交付上面应用层中的相应进程。

⑤ 网络层

两台计算机之间传送数据时其通信链路往往不止一条，所传输的信息甚至可能经过很多通信子网。网络层的主要任务就是选择合适的网间路由和交换节点，确保数据按时成功传送。在发送数据时，网络层把传输层产生的报文或用户数据报封装成分组和包向下传输到数据链路层。在网络层使用的协议是无连接的网际协议（Internet Protocol）和许多路由协议，因此我们通常把该层简单地称为 IP 层。

⑥ 数据链路层

数据链路层通常也叫做链路层，在物理层和网络层之间。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层协议。在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息。通过控制信息我们可以知道一个帧的起止比特位置，此外，也能使接收端检测出所收到的帧有无差错，如果发现差错，数据链路层能够简单的丢弃掉这个帧，以避免继续占用网络资源。

⑦ 物理层

作为 OSI 参考模型中最低的一层，物理层的作用是实现计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。该层的主要任务是确定与传输媒体的接口的一些特性（机械特性、电气特性、功能特性，过程特性）。
## 2.TCP/IP参考模型
## ​ OSI 七层模型在提出时的出发点是基于标准化的考虑，而没有考虑到具体的市场需求，使得该模型结构复杂，部分功能冗余，因而完全实现 OSI 参考模型的系统不多。而 TCP/IP 参考模型直接面向市场需求，实现起来也比较容易，因此在一经提出便得到了广泛的应用。基于 TCP/IP 的参考模型将协议分成四个层次，如上图所示，它们分别是：网络访问层、网际互联层、传输层、和应用层。

① 应用层

TCP/IP 模型将 OSI 参考模型中的会话层、表示层和应用层的功能合并到一个应用层实现，通过不同的应用层协议为不同的应用提供服务。例如：FTP、Telnet、DNS、SMTP 等。

② 传输层

该层对应于 OSI 参考模型的传输层，为上层实体提供源端到对端主机的通信功能。传输层定义了两个主要协议：传输控制协议（TCP）和用户数据报协议（UDP）。其中面向连接的 TCP 协议保证了数据的传输可靠性，面向无连接的 UDP 协议能够实现数据包简单、快速地传输。

③ 网际互联层

网际互联层对应 OSI 参考模型的网络层，主要负责相同或不同网络中计算机之间的通信。在网际互联层， IP 协议提供的是一个不可靠、无连接的数据报传递服务。该协议实现两个基本功能：寻址和分段。根据数据报报头中的目的地址将数据传送到目的地址，在这个过程中 IP 负责选择传送路线。除了 IP 协议外，该层另外两个主要协议是互联网组管理协议（IGMP）和互联网控制报文协议（ICMP）。

④ 网络接入层

网络接入层的功能对应于 OSI 参考模型中的物理层和数据链路层，它负责监视数据在主机和网络之间的交换。事实上，TCP/IP 并未真正描述这一层的实现，而由参与互连的各网络使用自己的物理层和数据链路层协议，然后与 TCP/IP 的网络接入层进行连接，因此具体的实现方法将随着网络类型的不同而有所差异。
![2021_05_28_image.png](https://cdn.logseq.com/%2F1e5b0e5f-d368-4a5d-86eb-09a690ee15d758345f0c-fa81-4885-8777-d6f48c3749bd2021_05_28_image.png?Expires=4775767842&Signature=OA96UtbH59LuksPyHOMhUD3yLSLCAjqqxJBIiCjAC0qHrs8nNy-tswJhOHnt5XsbzjzNoFmznlYM8s1ulGcVj2LDqYycGkvKevUfVPQEyOEOA8mgXkNchg~qfEH1wBhR-RMQzMbV2boKdyf0e4qPRjmdGyMpVoNKcDZBIdlO~IviF0px3~nWXvq59kRNsDMvdv6HL14gfnN18Ri1dFtzG9RAS0EYNypXr~TOx5lRtSNOjrF68uExsYye7Fis2Xsp3BxlelE5cQHZ7CygjIoA8~A7J8y11wOrHIjiUcwCw5iWs7mLGchISXG~CzGiTlv~7LpNkkTnnwceSzwsZUw2cQ__&Key-Pair-Id=APKAJE5CCD6X7MP6PTEA) 
**为什么 TCP/IP 去除了表示层和会话层？**
## OSI 参考模型在提出时，他们的理想是非常好的，但实际上，由于会话层、表示层、应用层都是在应用程序内部实现的，最终产出的是一个应用数据包，而应用程序之间是几乎无法实现代码的抽象共享的，这也就造成 OSI 设想中的应用程序维度的分层是无法实现的，例如，我们几乎不会认为数据的压缩、加密算法算是一种协议，而会话的概念则更为抽象，难以用协议来进行描述，所以在后来的 TCP/IP 协议框架的设计中，便将表示层和会话层与应用层整合在一起，让整个过程更为清晰明了。
**数据如何在各层之间传输【数据的封装过程】**
## 在发送主机端，一个应用层报文被传送到运输层。在最简单的情况下，运输层收取到报文并附上附加信息，该首部将被接收端的运输层使用。应用层报文和运输层首部信息一道构成了运输层报文段。附加的信息可能包括：**允许接收端运输层向上向适当的应用程序交付报文的信息以及差错检测位信息。**该信息让接收端能够判断报文中的比特是否在途中已被改变。运输层则向网络层传递该报文段，**网络层增加了如源和目的端系统地址等网络层首部信息**，生成了网络层数据报。该数据报接下来被传递给链路层，在**数据链路层数据包添加发送端 MAC 地址和接收端 MAC 地址后被封装成数据帧**，在物理层数据帧被封装成比特流，之后通过传输介质传送到对端。
## 3.应用层
## 3.1 HTTP 头部包含哪些信息
    HTTP 头部本质上是一个传递额外重要信息的键值对。主要分为：通用头部，请求头部，响应头部和实体头部。
## ![2021_05_28_image.png](https://cdn.logseq.com/%2F1e5b0e5f-d368-4a5d-86eb-09a690ee15d7dc6310b0-a304-411b-a2bd-09cf7ad8bca72021_05_28_image.png?Expires=4775768572&Signature=FbG1I6yjbBw3PfAg1LknVfwT1Gf50kwwv13qG-bfa0l7DLei8LEe4MVl6dTxZy4rM~NRH~IV40~gzgY3qvva9FovTXaVcmxyK1eDswKnJBA9TqNL4gH0~SJb0Bto-buQSvQ-2-YmeIOy-jGjpIDtT7W03gC7CLtvmAYb4Ifons7aiCBibYuXS1g6qpYhgZU~j71QLwP-oHFYfnU-4XTljqbsIquzBN5BIuWTiqa~qR6d9CO81yth-T1C6Nr7Uo4TB3Kx5-gFhXTjYAG9NzzWwyueUy~pBWTkMzCPTgxh80YkLJ3ADsrvAtVv6v47mJmfJqR4SabtWxEaTS5Ll4xyaA__&Key-Pair-Id=APKAJE5CCD6X7MP6PTEA)
## ![2021_05_28_image.png](https://cdn.logseq.com/%2F1e5b0e5f-d368-4a5d-86eb-09a690ee15d7898abeae-d15d-4d46-8cad-a302c29e09be2021_05_28_image.png?Expires=4775768614&Signature=e~kzY62vgGWpPJ9MaT-wmzrUNzYMGdgeULYhLSpCJtsjJjPG-q2z8x3xmso0C3JRExFPdqYMsIDcP60blVAKBkop8kaR03AGxkMkbNACrU7AD1ka6BDTRZiM1fvGqAQ24McPEO4irxU2ShiuzA3yUMFf2TyCT1S3HnM5FtWkiuRHjqv7l7oYon~wCl9Y78FRVDO-cncxLZkXT2YCu6ye~xyGj5kwDxqZsy~t1DLH3L5jGvAASeplwIym3N8pVW2tlJtW0jcCod2Xa8dU~Wn2gUzEgvy8nt3RAO-DniyO3meYrZZThO6EzWfuo3bP7frLaOF6~peuAErAM-u85AWakA__&Key-Pair-Id=APKAJE5CCD6X7MP6PTEA)
## ![2021_05_28_image.png](https://cdn.logseq.com/%2F1e5b0e5f-d368-4a5d-86eb-09a690ee15d7debdda86-84c3-4b4d-9079-5b027fb6d6542021_05_28_image.png?Expires=4775768634&Signature=RE-76a5ZJ9WOoARVBrhcAH0WxOVy~xYqMzqvLxmz8cQe4DYsEgp-pqCPMdHSi6IKgDum1-pGMUORFh5YGL2k9SFlk8kXSrpNaOzksrzPfGPLh6Cq6WaVxYCMCZjAsJAItuVz0~7MMUt4UQP7clIM0INFtpFBJ61~ubuR-V0Tgyp-0WLgqy2~wjpu-LczzifGf~DZPTm0waExmvyH11i88BSmjr3CwtuDKjC1vrsOcPajRtDKqQwA2~9XEkdYsivjqhQnWN4r17sNfxg8zE3HoVlK56XTgYpzwHaNtpUBlh8FCyUs0jw~WDJC~bvGN3m5HrPIprtYULPqFqOEVOB5zw__&Key-Pair-Id=APKAJE5CCD6X7MP6PTEA)
## ![2021_05_28_image.png](https://cdn.logseq.com/%2F1e5b0e5f-d368-4a5d-86eb-09a690ee15d7ae439ad3-9b94-437c-9e00-4cb885443c9d2021_05_28_image.png?Expires=4775768649&Signature=DF3IJ9rqDZwB4Fe3XDSi4Ysn3831NDo6UGyzCavWqfh7PMZPO~YYDRxqbN30k57H-d2c6z9MwCFObvqDJMdIbsV0HK4FXolqrPk9PHXjCJ0vZ0C20pJtpVde-LTbgZplZJny1Ihsed54Vhcn-hImf7ZTGSE-PD-Pc0tjQ2ZKwTWTDqPx~q24UHF679tV~O8WGwH7T9b7Vp~u5FiMAYwaXf~bafJ~cZsI5OhRKUyZE5OZO~a8O-NWzpSbOlByJWtN7D-fjuaLWO2h6PI5~7UVe-HACkfb579wU9PEhim~yqI7KPgsKpZK~Nic~Awyuy7OVaLqAbnWt~jC8vvL~y~B2g__&Key-Pair-Id=APKAJE5CCD6X7MP6PTEA)
## 总结：
## *通用头*：是客户端和服务器都可以使用的头部，可以在客户端、服务器和其他应用程序之间提供一些非常有用的通用功能，如Date头部。
*请求头*：是请求报文特有的，它们为服务器提供了一些额外信息，比如客户端希望接收什么类型的数据，如Accept头部。
*响应头*：便于客户端提供信息，比如，客服端在与哪种类型的服务器进行交互，如Server头部。
*实体头*：指的是用于应对实体主体部分的头部，比如，可以用实体头部来说明实体主体部分的数据类型，如Content-Type头部。
## 3.2 keepAlive 和非keepAlive区别（长连接和短连接的区别）
## HTTP/1.0 中，浏览器每次 发起 HTTP 请求都要与服务器创建一个新的 TCP 连接，服务器完成请求处理后立即断开 TCP 连接，服务器不跟踪每个客户也不记录过去的请求。然而创建和关闭连接的过程需要消耗资源和时间，为了减少资源消耗，缩短响应时间，就需要重用连接。在 HTTP/1.1 版本中默认使用持久连接，在此之前的 HTTP 版本的默认连接都是使用非持久连接，如果想要在旧版本的 HTTP 协议上维持持久连接，则需要指定 connection 的首部字段的值为 Keep-Alive 来告诉对方这个请求响应完成后不要关闭，下一次咱们还用这个请求继续交流
![2021_05_28_image.png](https://cdn.logseq.com/%2F1e5b0e5f-d368-4a5d-86eb-09a690ee15d7210b38bb-4ce4-4d09-acac-2bf75d1de4852021_05_28_image.png?Expires=4775778307&Signature=L~GHkolatru7LPISrl~6Hs2Wc5DCAQLRRzmMro7iOwKNAHrzR3NlqidbGpPakGluG3d3obIhHVvSxXPWX4mpWPUmuw92WCccGZF5JwjUERSg66Rjk-kEY7m0SYvRb6ZYnJij2l3g7PdUULhl4c760d8zm72YOAb8VMZSvRM2DeYuPKNjCioPfY4abWUWcpsEJzWsJcSl4T8M7iSpdYXXnXNiiGfCQfG5pRS5ENFbfa847yUTlC6qdc456j3mJlz9ItCl1MJsNlHMNa-NW3lYnlBoL3Fmx6vEZk--VvKYdGI8bjKCScqNIRjAcrW9zzMEn6Q5yQRayPpEtBwCXy0TeA__&Key-Pair-Id=APKAJE5CCD6X7MP6PTEA) 
对于非 Keep=Alive 来说，必须为每一个请求的对象建立和维护一个全新的连接。对于每一个这样的连接，**客户机和服务器都要分配 TCP 的缓冲区和变量，这给服务器带来的严重的负担
**；在 Keep-Alive 方式下，服务器在响应后保持该 TCP 连接打开，在同一个客户机与服务器之间的后续请求和响应报文可通过相同的连接进行传送。甚至位于同一台服务器的多个 Web 页面在从该服务器发送给同一个客户机时，可以在单个持久 TCP 连接上进行。若对 Keep-Alive 模式配置不当，将有可能比非 Keep-Alive 模式带来的损失更大。因此，我们需要正确地设置 keep-alive timeout 参数，当 TCP 连接在传送完最后一个 HTTP 响应，该连接会保持 keepalive_timeout 秒，之后就开始关闭这个链接。
## 4.**HTTP 长连接短连接使用场景是什么**
## 长连接：多用于操作频繁，点对点的通讯，而且客户端连接数目较少的情况。例如即时通讯、网络游戏等。

短连接：用户数目较多的Web网站的 HTTP 服务一般用短连接。例如京东，淘宝这样的大型网站一般客户端数量达到千万级甚至上亿，若采用长连接势必会使得服务端大量的资源被无效占用，所以一般使用的是短连接。
## 5.**怎么知道 HTTP 的报文长度**
## 如果服务器能够很清楚的知道请求内容的大小，那么可以通过消息首部字段 Content- Length 来告诉客户端需要接收多少数据，如果服务器预先不知道请求内容的大小，例如加载动态页面的时候，就需要使用 Transfer-Encoding: chunked 的方式来代替 Content-Length
## 分块传输编码（Chunked transfer encoding）是 **HTTP/1.1** 中引入的一种数据传输机制，其**允许 HTTP 由服务器发送给客户端的数据可以分成多个部分**，当数据分解成一系列数据块发送时，服务器就可以发送数据而不需要预先知道发送内容的总大小，每一个分块包含十六进制的长度值和数据，最后一个分块长度值为0，表示实体结束，客户机可以以此为标志确认数据已经接收完毕。
## 6.**HTTP 方法**
## HTTP/1.0 定义了三种请求方法：**GET, POST 和 HEAD 方法。**

HTTP/1.1 增加了六种请求方法：**OPTIONS, PUT, PATCH, DELETE, TRACE 和 CONNECT 方法。**
## ![2021_05_28_image.png](https://cdn.logseq.com/%2F1e5b0e5f-d368-4a5d-86eb-09a690ee15d7431d0d85-1752-4f64-ba63-731e35d08fce2021_05_28_image.png?Expires=4775781584&Signature=Xx2IQs7UBExXclhTZnSy4FjLpEjDcyJVo9x-kx9D-2vsNhKaQ5dDPBcC3oZH8wH-j52zmt-gpLLKkjZG53pJiqxeQ4fOxoJwqiqtn5wmXZvgjRWzrEqYO79fm00Ub7NSStojvQzBqJUBtIjtmoOT7I1F3zNyqBZnnkNXF-3~BR0vU8gu8-4B90iVLJNqR24joyknCBlcsd48oJ6VAzYNgBBcQZmZED733nmQwsEZ2aKMER4IQt8f-l8espcjaCup6AT5rO7t9agu~Gcmq9W7VsKvpZOPSyjbFUK7-CfA~p5TMBPTMJbbxL7X7aT9yxt3~JfJnyWLtk90GElbTlvx3g__&Key-Pair-Id=APKAJE5CCD6X7MP6PTEA)
## 7.**GET 和 POST 的区别**(很重要)
## get 提交的数据会放在 URL 之后，并且请求参数会被完整的保留在浏览器的记录里，由于参数直接暴露在 URL 中，可能会存在安全问题，因此往往用于获取资源信息。而 post 参数放在请求主体中，并且参数不会被保留，相比 get 方法，post 方法更安全，主要用于修改服务器上的资源。
get 请求只支持 URL 编码，post 请求支持多种编码格式。
get 提交的数据大小有限制（这里所说的限制是针对浏览器而言的），而 post 方法提交的数据没限制
get 方式需要使用 Request.QueryString 来取得变量的值，而 post 方式通过 Request.Form 来获取。
## **对于GET方式的请求，浏览器会把http header和data一并发送出去，服务端响应200，请求成功。**
**对于POST方式的请求，浏览器会先发送http header给服务端，告诉服务端等一下会有数据过来，服务端响应100 continue，告诉浏览器我已经准备接收数据，浏览器再post发送一个data给服务端，服务端响应200，请求成功。**
## **一个关键的东西：为什么get有长度限制？**
## HTTP 中的 GET 方法是通过 URL 传递数据的，而 **URL 本身并没有对数据的长度进行限制，真正限制 GET 长度的是浏览器**，例如 IE 浏览器对 URL 的最大限制为 2000多个字符，大概 2KB左右，像 Chrome, FireFox 等浏览器能支持的 URL 字符数更多，其中 FireFox 中 URL 最大长度限制为 65536 个字符，Chrome 浏览器中 URL 最大长度限制为 8182 个字符。并且这个长度不是只针对数据部分，而是针对整个 URL 而言，在这之中，不同的服务器同样影响 URL 的最大长度限制。因此对于特定的浏览器，GET的长度限制不同。

由于 POST 方法请求参数在请求主体中，理论上讲，post 方法是没有大小限制的，而真正起限制作用的是服务器处理程序的处理能力。
## HTTP 与 HTTPs 的工作方式：
    HTTP：HTTP（Hyper Text Transfer Protocol: 超文本传输协议） 是一种简单的请求 - 响应协议，被用于在 Web 浏览器和网站服务器之间传递消息。HTTP 使用 TCP（而不是 UDP）作为它的支撑运输层协议。其默认工作在 TCP 协议 （80 端口），HTTP 客户机发起一个与服务器的 TCP 连接，一旦连接建立，浏览器和服务器进程就可以通过套接字接口访问 TCP。客户机从套接字接口发送 HTTP 请求报文和接收 HTTP 响应报文。类似地，服务器也是从套接字接口接收 HTTP 请求报文和发送 HTTP 响应报文。其通信内容以明文的方式发送，不通过任何方式的数据加密。当通信结束时，客户端与服务器关闭连接。
    HTTPS：HTTPS（Hyper Text Transfer Protocol over Secure Socket Layer）是以安全为目标的 HTTP 协议，在 HTTP 的基础上通过传输加密和身份认证的方式保证了传输过程的安全性。其工作流程如下：
① 客户端发起一个 HTTPS 请求，并连接到服务器的 443 端口，发送的信息主要包括自身所支持的算法列表和密钥长度等；

② 服务端将自身所支持的所有加密算法与客户端的算法列表进行对比并选择一种支持的加密算法，然后将它和其它密钥组件一同发送给客户端。

③ 服务器向客户端发送一个包含数字证书的报文，该数字证书中包含证书的颁发机构、过期时间、服务端的公钥等信息。

④ 最后服务端发送一个完成报文通知客户端 SSL 的第一阶段已经协商完成。

⑤ SSL 第一次协商完成后，客户端发送一个回应报文，报文中包含一个客户端生成的随机密码串，称为 pre_master_secre，并且该报文是经过证书中的公钥加密过的。

⑥ 紧接着客户端会发送一个报文提示服务端在此之后的报文是采用pre_master_secre 加密的。

⑦ 客户端向服务端发送一个 finish 报文，这次握手中包含第一次握手至今所有报文的整体校验值，最终协商是否完成取决于服务端能否成功解密。

⑧ 服务端同样发送与第 ⑥ 步中相同作用的报文，已让客户端进行确认，最后发送 finish 报文告诉客户端自己能够正确解密报文。

当服务端和客户端的 finish 报文交换完成之后，SSL 连接就算建立完成了，之后就进行和 HTTP 相同的通信过程，唯一不同的是在 HTTP 通信过程中并不是采用明文传输，而是采用对称加密的方式，其中对称密钥已经在 SSL 的建立过程中协商好了。
## HTTPS 和 HTTP 的区别：
    HTTP 协议以明文方式发送内容，数据都是未加密的，安全性较差。HTTPS 数据传输过程是加密的，安全性较好。
    HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80 端口，后者是 443 端口。
    HTTPS 协议需要到数字认证机构（Certificate Authority, CA）申请证书，一般需要一定的费用。
    HTTP 页面响应比 HTTPS 快，主要因为 HTTP 使用 3 次握手建立连接，客户端和服务器需要握手 3 次，而 HTTPS 除了 TCP 的 3 次握手，还需要经历一个 SSL 协商过程。
## 为什么要CA:
## 防止中间人篡改公钥SPK为MPK，和客户端联系（相当于中间加了个服务器，服务器自己用SPK和服务器通信，用MPK和客户端通信）中间人没有 CA 机构的私钥；另外，数字证书中包含了服务端的域名，如果中间人掉包会出现错误的服务器域名（还是有点问题，这里掉包不能换域名吗？只有一种解释方法那就是他不知道客户端的域名，即无法解密含CA的报文），**客户端会与CA通信看看来的报文是不是没被篡改过的**
## 8.HTTP 是不保存状态的协议,如何保存用户状态？
    两种解决方案：
    ① 基于 Session 实现的会话保持：在客户端第一次向服务器发送 HTTP 请求后，服务器会创建一个 Session 对象并将客户端的身份信息以键值对的形式存储下来，然后分配一个会话标识（SessionId）给客户端，这个会话标识一般保存在客户端 Cookie 中，之后每次该浏览器发送 HTTP 请求都会带上 Cookie 中的 SessionId 到服务器，服务器根据会话标识就可以将之前的状态信息与会话联系起来，从而实现会话保持。
    优点：安全性高，因为状态信息保存在服务器端。
    缺点：由于大型网站往往采用的是分布式服务器，浏览器发送的 HTTP 请求一般要先通过负载均衡器才能到达具体的后台服务器，倘若同一个浏览器两次 HTTP 请求分别落在不同的服务器上时，基于 Session 的方法就不能实现会话保持了。
    **【解决方法：采用中间件，例如 Redis，我们通过将 Session 的信息存储在 Redis 中，使得每个服务器都可以访问到之前的状态信息】**
    ② 基于 Cookie 实现的会话保持：当服务器发送响应消息时，在 HTTP 响应头中设置 Set-Cookie 字段，用来存储客户端的状态信息。客户端解析出 HTTP 响应头中的字段信息，并根据其生命周期创建不同的 Cookie，这样一来每次浏览器发送 HTTP 请求的时候都会带上 Cookie 字段，从而实现状态保持。基于 Cookie 的会话保持与基于 Session 实现的会话保持最主要的区别是前者完全将会话状态信息存储在浏览器 Cookie 中。

优点：服务器不用保存状态信息， 减轻服务器存储压力，同时便于服务端做水平拓展。

缺点：该方式不够安全，因为状态信息存储在客户端，这意味着不能在会话中保存机密数据。除此之外，浏览器每次发起 HTTP 请求时都需要发送额外的 Cookie 到服务器端，会占用更多带宽。
## 个人总结：1.session是要配合cookie才有用的
