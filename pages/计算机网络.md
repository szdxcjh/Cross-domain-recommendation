---
title: 计算机网络
---

## 1.OSI七层（或其他）参考模型
## ![2021_05_28_image.png](https://cdn.logseq.com/%2F1e5b0e5f-d368-4a5d-86eb-09a690ee15d7d0d6e7a0-0d12-4612-bb2f-15aee417044f2021_05_28_image.png?Expires=4775767112&Signature=RYnXru6JccQ6RYv4bO5x4hCfugIiHwy9u6YMnbs40gFMKY~FLLW9HH3E~K-kZrUM6oZ1DwkB3d87ktlfeHnj0cEuZeXZwuotE90bxzwSqR5FkWIHv1esFn2tf99cESw67fY6TVzsUzN7zoFqtYi3NqsRfP~6e72GNWHs7UN-zRBxWUHS7pSrJ9ZAm39rvXBW66Vcsdm2aEvwFefyto-YpH6TP3f7BaGVFZxdtBkkYAaQX4LRT7K0Ky8uwE7EFugAsOJFBRSZjZYpaLAnxZRfGp~-bG~yeHqxC0kn3Ntl3pN3Dal4ei3GGJkEZoVSow4c5islR~Hmi324fKrQzB8Pmw__&Key-Pair-Id=APKAJE5CCD6X7MP6PTEA)
## OSI 模型全称为开放式通信系统互连参考模型，是国际标准化组织 ( ISO ) 提出的一个试图使各种计算机在世界范围内互连为网络的标准框架。 OSI 将计算机网络体系结构划分为七层，每一层实现各自的功能和协议，并完成与相邻层的接口通信。OSI 的服务定义详细说明了各层所提供的服务。某一层的服务就是该层及其下各层的一种能力，它通过接口提供给更高一层。各层所提供的服务与这些服务是怎么实现的无关。
① 应用层

应用层位于 OSI 参考模型的第七层，其作用是通过应用程序间的交互来完成特定的网络应用。该层协议定义了应用进程之间的交互规则，通过不同的应用层协议为不同的网络应用提供服务。例如域名系统 DNS，支持万维网应用的 HTTP 协议，电子邮件系统采用的 SMTP 协议等。在应用层交互的数据单元我们称之为报文。
② 表示层

表示层的作用是使通信的应用程序能够解释交换数据的含义，其位于 OSI 参考模型的第六层，向上为应用层提供服务，向下接收来自会话层的服务。该层提供的服务主要包括数据压缩，数据加密以及数据描述。这使得应用程序不必担心在各台计算机中表示和存储的内部格式差异。

③ 会话层

会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法。

④ 传输层

传输层的主要任务是为两台主机进程之间的通信提供服务。应用程序利用该服务传送应用层报文。该服务并不针对某一特定的应用，多种应用可以使用同一个传输层服务。由于一台主机可同时运行多个线程，因此传输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面传输层的服务，分用和复用相反，是传输层把收到的信息分别交付上面应用层中的相应进程。

⑤ 网络层

两台计算机之间传送数据时其通信链路往往不止一条，所传输的信息甚至可能经过很多通信子网。网络层的主要任务就是选择合适的网间路由和交换节点，确保数据按时成功传送。在发送数据时，网络层把传输层产生的报文或用户数据报封装成分组和包向下传输到数据链路层。在网络层使用的协议是无连接的网际协议（Internet Protocol）和许多路由协议，因此我们通常把该层简单地称为 IP 层。

⑥ 数据链路层

数据链路层通常也叫做链路层，在物理层和网络层之间。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层协议。在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息。通过控制信息我们可以知道一个帧的起止比特位置，此外，也能使接收端检测出所收到的帧有无差错，如果发现差错，数据链路层能够简单的丢弃掉这个帧，以避免继续占用网络资源。

⑦ 物理层

作为 OSI 参考模型中最低的一层，物理层的作用是实现计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。该层的主要任务是确定与传输媒体的接口的一些特性（机械特性、电气特性、功能特性，过程特性）。
## 2.TCP/IP参考模型
## ​ OSI 七层模型在提出时的出发点是基于标准化的考虑，而没有考虑到具体的市场需求，使得该模型结构复杂，部分功能冗余，因而完全实现 OSI 参考模型的系统不多。而 TCP/IP 参考模型直接面向市场需求，实现起来也比较容易，因此在一经提出便得到了广泛的应用。基于 TCP/IP 的参考模型将协议分成四个层次，如上图所示，它们分别是：网络访问层、网际互联层、传输层、和应用层。

① 应用层

TCP/IP 模型将 OSI 参考模型中的会话层、表示层和应用层的功能合并到一个应用层实现，通过不同的应用层协议为不同的应用提供服务。例如：FTP、Telnet、DNS、SMTP 等。

② 传输层

该层对应于 OSI 参考模型的传输层，为上层实体提供源端到对端主机的通信功能。传输层定义了两个主要协议：传输控制协议（TCP）和用户数据报协议（UDP）。其中面向连接的 TCP 协议保证了数据的传输可靠性，面向无连接的 UDP 协议能够实现数据包简单、快速地传输。

③ 网际互联层

网际互联层对应 OSI 参考模型的网络层，主要负责相同或不同网络中计算机之间的通信。在网际互联层， IP 协议提供的是一个不可靠、无连接的数据报传递服务。该协议实现两个基本功能：寻址和分段。根据数据报报头中的目的地址将数据传送到目的地址，在这个过程中 IP 负责选择传送路线。除了 IP 协议外，该层另外两个主要协议是互联网组管理协议（IGMP）和互联网控制报文协议（ICMP）。

④ 网络接入层

网络接入层的功能对应于 OSI 参考模型中的物理层和数据链路层，它负责监视数据在主机和网络之间的交换。事实上，TCP/IP 并未真正描述这一层的实现，而由参与互连的各网络使用自己的物理层和数据链路层协议，然后与 TCP/IP 的网络接入层进行连接，因此具体的实现方法将随着网络类型的不同而有所差异。
![2021_05_28_image.png](https://cdn.logseq.com/%2F1e5b0e5f-d368-4a5d-86eb-09a690ee15d758345f0c-fa81-4885-8777-d6f48c3749bd2021_05_28_image.png?Expires=4775767842&Signature=OA96UtbH59LuksPyHOMhUD3yLSLCAjqqxJBIiCjAC0qHrs8nNy-tswJhOHnt5XsbzjzNoFmznlYM8s1ulGcVj2LDqYycGkvKevUfVPQEyOEOA8mgXkNchg~qfEH1wBhR-RMQzMbV2boKdyf0e4qPRjmdGyMpVoNKcDZBIdlO~IviF0px3~nWXvq59kRNsDMvdv6HL14gfnN18Ri1dFtzG9RAS0EYNypXr~TOx5lRtSNOjrF68uExsYye7Fis2Xsp3BxlelE5cQHZ7CygjIoA8~A7J8y11wOrHIjiUcwCw5iWs7mLGchISXG~CzGiTlv~7LpNkkTnnwceSzwsZUw2cQ__&Key-Pair-Id=APKAJE5CCD6X7MP6PTEA) 
**为什么 TCP/IP 去除了表示层和会话层？**
## OSI 参考模型在提出时，他们的理想是非常好的，但实际上，由于会话层、表示层、应用层都是在应用程序内部实现的，最终产出的是一个应用数据包，而应用程序之间是几乎无法实现代码的抽象共享的，这也就造成 OSI 设想中的应用程序维度的分层是无法实现的，例如，我们几乎不会认为数据的压缩、加密算法算是一种协议，而会话的概念则更为抽象，难以用协议来进行描述，所以在后来的 TCP/IP 协议框架的设计中，便将表示层和会话层与应用层整合在一起，让整个过程更为清晰明了。
**数据如何在各层之间传输【数据的封装过程】**
## 在发送主机端，一个应用层报文被传送到运输层。在最简单的情况下，运输层收取到报文并附上附加信息，该首部将被接收端的运输层使用。应用层报文和运输层首部信息一道构成了运输层报文段。附加的信息可能包括：**允许接收端运输层向上向适当的应用程序交付报文的信息以及差错检测位信息。**该信息让接收端能够判断报文中的比特是否在途中已被改变。运输层则向网络层传递该报文段，**网络层增加了如源和目的端系统地址等网络层首部信息**，生成了网络层数据报。该数据报接下来被传递给链路层，在**数据链路层数据包添加发送端 MAC 地址和接收端 MAC 地址后被封装成数据帧**，在物理层数据帧被封装成比特流，之后通过传输介质传送到对端。
## 3.应用层
## 3.1 HTTP 头部包含哪些信息
    HTTP 头部本质上是一个传递额外重要信息的键值对。主要分为：通用头部，请求头部，响应头部和实体头部。
## ![2021_05_28_image.png](https://cdn.logseq.com/%2F1e5b0e5f-d368-4a5d-86eb-09a690ee15d7dc6310b0-a304-411b-a2bd-09cf7ad8bca72021_05_28_image.png?Expires=4775768572&Signature=FbG1I6yjbBw3PfAg1LknVfwT1Gf50kwwv13qG-bfa0l7DLei8LEe4MVl6dTxZy4rM~NRH~IV40~gzgY3qvva9FovTXaVcmxyK1eDswKnJBA9TqNL4gH0~SJb0Bto-buQSvQ-2-YmeIOy-jGjpIDtT7W03gC7CLtvmAYb4Ifons7aiCBibYuXS1g6qpYhgZU~j71QLwP-oHFYfnU-4XTljqbsIquzBN5BIuWTiqa~qR6d9CO81yth-T1C6Nr7Uo4TB3Kx5-gFhXTjYAG9NzzWwyueUy~pBWTkMzCPTgxh80YkLJ3ADsrvAtVv6v47mJmfJqR4SabtWxEaTS5Ll4xyaA__&Key-Pair-Id=APKAJE5CCD6X7MP6PTEA)
## ![2021_05_28_image.png](https://cdn.logseq.com/%2F1e5b0e5f-d368-4a5d-86eb-09a690ee15d7898abeae-d15d-4d46-8cad-a302c29e09be2021_05_28_image.png?Expires=4775768614&Signature=e~kzY62vgGWpPJ9MaT-wmzrUNzYMGdgeULYhLSpCJtsjJjPG-q2z8x3xmso0C3JRExFPdqYMsIDcP60blVAKBkop8kaR03AGxkMkbNACrU7AD1ka6BDTRZiM1fvGqAQ24McPEO4irxU2ShiuzA3yUMFf2TyCT1S3HnM5FtWkiuRHjqv7l7oYon~wCl9Y78FRVDO-cncxLZkXT2YCu6ye~xyGj5kwDxqZsy~t1DLH3L5jGvAASeplwIym3N8pVW2tlJtW0jcCod2Xa8dU~Wn2gUzEgvy8nt3RAO-DniyO3meYrZZThO6EzWfuo3bP7frLaOF6~peuAErAM-u85AWakA__&Key-Pair-Id=APKAJE5CCD6X7MP6PTEA)
## ![2021_05_28_image.png](https://cdn.logseq.com/%2F1e5b0e5f-d368-4a5d-86eb-09a690ee15d7debdda86-84c3-4b4d-9079-5b027fb6d6542021_05_28_image.png?Expires=4775768634&Signature=RE-76a5ZJ9WOoARVBrhcAH0WxOVy~xYqMzqvLxmz8cQe4DYsEgp-pqCPMdHSi6IKgDum1-pGMUORFh5YGL2k9SFlk8kXSrpNaOzksrzPfGPLh6Cq6WaVxYCMCZjAsJAItuVz0~7MMUt4UQP7clIM0INFtpFBJ61~ubuR-V0Tgyp-0WLgqy2~wjpu-LczzifGf~DZPTm0waExmvyH11i88BSmjr3CwtuDKjC1vrsOcPajRtDKqQwA2~9XEkdYsivjqhQnWN4r17sNfxg8zE3HoVlK56XTgYpzwHaNtpUBlh8FCyUs0jw~WDJC~bvGN3m5HrPIprtYULPqFqOEVOB5zw__&Key-Pair-Id=APKAJE5CCD6X7MP6PTEA)
## ![2021_05_28_image.png](https://cdn.logseq.com/%2F1e5b0e5f-d368-4a5d-86eb-09a690ee15d7ae439ad3-9b94-437c-9e00-4cb885443c9d2021_05_28_image.png?Expires=4775768649&Signature=DF3IJ9rqDZwB4Fe3XDSi4Ysn3831NDo6UGyzCavWqfh7PMZPO~YYDRxqbN30k57H-d2c6z9MwCFObvqDJMdIbsV0HK4FXolqrPk9PHXjCJ0vZ0C20pJtpVde-LTbgZplZJny1Ihsed54Vhcn-hImf7ZTGSE-PD-Pc0tjQ2ZKwTWTDqPx~q24UHF679tV~O8WGwH7T9b7Vp~u5FiMAYwaXf~bafJ~cZsI5OhRKUyZE5OZO~a8O-NWzpSbOlByJWtN7D-fjuaLWO2h6PI5~7UVe-HACkfb579wU9PEhim~yqI7KPgsKpZK~Nic~Awyuy7OVaLqAbnWt~jC8vvL~y~B2g__&Key-Pair-Id=APKAJE5CCD6X7MP6PTEA)
## 总结：
## *通用头*：是客户端和服务器都可以使用的头部，可以在客户端、服务器和其他应用程序之间提供一些非常有用的通用功能，如Date头部。
*请求头*：是请求报文特有的，它们为服务器提供了一些额外信息，比如客户端希望接收什么类型的数据，如Accept头部。
*响应头*：便于客户端提供信息，比如，客服端在与哪种类型的服务器进行交互，如Server头部。
*实体头*：指的是用于应对实体主体部分的头部，比如，可以用实体头部来说明实体主体部分的数据类型，如Content-Type头部。
## 3.2 keepAlive 和非keepAlive区别（长连接和短连接的区别）
## HTTP/1.0 中，浏览器每次 发起 HTTP 请求都要与服务器创建一个新的 TCP 连接，服务器完成请求处理后立即断开 TCP 连接，服务器不跟踪每个客户也不记录过去的请求。然而创建和关闭连接的过程需要消耗资源和时间，为了减少资源消耗，缩短响应时间，就需要重用连接。在 HTTP/1.1 版本中默认使用持久连接，在此之前的 HTTP 版本的默认连接都是使用非持久连接，如果想要在旧版本的 HTTP 协议上维持持久连接，则需要指定 connection 的首部字段的值为 Keep-Alive 来告诉对方这个请求响应完成后不要关闭，下一次咱们还用这个请求继续交流
![2021_05_28_image.png](https://cdn.logseq.com/%2F1e5b0e5f-d368-4a5d-86eb-09a690ee15d7210b38bb-4ce4-4d09-acac-2bf75d1de4852021_05_28_image.png?Expires=4775778307&Signature=L~GHkolatru7LPISrl~6Hs2Wc5DCAQLRRzmMro7iOwKNAHrzR3NlqidbGpPakGluG3d3obIhHVvSxXPWX4mpWPUmuw92WCccGZF5JwjUERSg66Rjk-kEY7m0SYvRb6ZYnJij2l3g7PdUULhl4c760d8zm72YOAb8VMZSvRM2DeYuPKNjCioPfY4abWUWcpsEJzWsJcSl4T8M7iSpdYXXnXNiiGfCQfG5pRS5ENFbfa847yUTlC6qdc456j3mJlz9ItCl1MJsNlHMNa-NW3lYnlBoL3Fmx6vEZk--VvKYdGI8bjKCScqNIRjAcrW9zzMEn6Q5yQRayPpEtBwCXy0TeA__&Key-Pair-Id=APKAJE5CCD6X7MP6PTEA) 
对于非 KeepAlive 来说，必须为每一个请求的对象建立和维护一个全新的连接。对于每一个这样的连接，**客户机和服务器都要分配 TCP 的缓冲区和变量，这给服务器带来的严重的负担
**；在 Keep-Alive 方式下，服务器在响应后保持该 TCP 连接打开，在同一个客户机与服务器之间的后续请求和响应报文可通过相同的连接进行传送。甚至位于同一台服务器的多个 Web 页面在从该服务器发送给同一个客户机时，可以在单个持久 TCP 连接上进行。若对 Keep-Alive 模式配置不当，将有可能比非 Keep-Alive 模式带来的损失更大。因此，我们需要正确地设置 keep-alive timeout 参数，当 TCP 连接在传送完最后一个 HTTP 响应，该连接会保持 keepalive_timeout 秒，之后就开始关闭这个链接。
## 4.**HTTP 长连接短连接使用场景是什么**
## 长连接：多用于操作频繁，点对点的通讯，而且客户端连接数目较少的情况。例如即时通讯、网络游戏等。

短连接：用户数目较多的Web网站的 HTTP 服务一般用短连接。例如京东，淘宝这样的大型网站一般客户端数量达到千万级甚至上亿，若采用长连接势必会使得服务端大量的资源被无效占用，所以一般使用的是短连接。
## 5.**怎么知道 HTTP 的报文长度**
## 如果服务器能够很清楚的知道请求内容的大小，那么可以通过消息首部字段 Content- Length 来告诉客户端需要接收多少数据，如果服务器预先不知道请求内容的大小，例如加载动态页面的时候，就需要使用 Transfer-Encoding: chunked 的方式来代替 Content-Length
## 分块传输编码（Chunked transfer encoding）是 **HTTP/1.1** 中引入的一种数据传输机制，其**允许 HTTP 由服务器发送给客户端的数据可以分成多个部分**，当数据分解成一系列数据块发送时，服务器就可以发送数据而不需要预先知道发送内容的总大小，每一个分块包含十六进制的长度值和数据，最后一个分块长度值为0，表示实体结束，客户机可以以此为标志确认数据已经接收完毕。
## 6.**HTTP 方法**
## HTTP/1.0 定义了三种请求方法：**GET, POST 和 HEAD 方法。**

HTTP/1.1 增加了六种请求方法：**OPTIONS, PUT, PATCH, DELETE, TRACE 和 CONNECT 方法。**
## ![2021_05_28_image.png](https://cdn.logseq.com/%2F1e5b0e5f-d368-4a5d-86eb-09a690ee15d7431d0d85-1752-4f64-ba63-731e35d08fce2021_05_28_image.png?Expires=4775781584&Signature=Xx2IQs7UBExXclhTZnSy4FjLpEjDcyJVo9x-kx9D-2vsNhKaQ5dDPBcC3oZH8wH-j52zmt-gpLLKkjZG53pJiqxeQ4fOxoJwqiqtn5wmXZvgjRWzrEqYO79fm00Ub7NSStojvQzBqJUBtIjtmoOT7I1F3zNyqBZnnkNXF-3~BR0vU8gu8-4B90iVLJNqR24joyknCBlcsd48oJ6VAzYNgBBcQZmZED733nmQwsEZ2aKMER4IQt8f-l8espcjaCup6AT5rO7t9agu~Gcmq9W7VsKvpZOPSyjbFUK7-CfA~p5TMBPTMJbbxL7X7aT9yxt3~JfJnyWLtk90GElbTlvx3g__&Key-Pair-Id=APKAJE5CCD6X7MP6PTEA)
## 7.**GET 和 POST 的区别**(很重要)
## get 提交的数据会放在 URL 之后，并且请求参数会被完整的保留在浏览器的记录里，由于参数直接暴露在 URL 中，可能会存在安全问题，因此往往用于获取资源信息。而 post 参数放在请求主体中，并且参数不会被保留，相比 get 方法，post 方法更安全，主要用于修改服务器上的资源。
get 请求只支持 URL 编码，post 请求支持多种编码格式。
get 提交的数据大小有限制（这里所说的限制是针对浏览器而言的），而 post 方法提交的数据没限制
get 方式需要使用 Request.QueryString 来取得变量的值，而 post 方式通过 Request.Form 来获取。
## **对于GET方式的请求，浏览器会把http header和data一并发送出去，服务端响应200，请求成功。**
**对于POST方式的请求，浏览器会先发送http header给服务端，告诉服务端等一下会有数据过来，服务端响应100 continue，告诉浏览器我已经准备接收数据，浏览器再post发送一个data给服务端，服务端响应200，请求成功。**
## **一个关键的东西：为什么get有长度限制？**
## HTTP 中的 GET 方法是通过 URL 传递数据的，而 **URL 本身并没有对数据的长度进行限制，真正限制 GET 长度的是浏览器**，例如 IE 浏览器对 URL 的最大限制为 2000多个字符，大概 2KB左右，像 Chrome, FireFox 等浏览器能支持的 URL 字符数更多，其中 FireFox 中 URL 最大长度限制为 65536 个字符，Chrome 浏览器中 URL 最大长度限制为 8182 个字符。并且这个长度不是只针对数据部分，而是针对整个 URL 而言，在这之中，不同的服务器同样影响 URL 的最大长度限制。因此对于特定的浏览器，GET的长度限制不同。

由于 POST 方法请求参数在请求主体中，理论上讲，post 方法是没有大小限制的，而真正起限制作用的是服务器处理程序的处理能力。
## HTTP 与 HTTPs 的工作方式：
HTTP：HTTP（Hyper Text Transfer Protocol: 超文本传输协议） 是一种简单的请求 - 响应协议，被用于在 Web 浏览器和网站服务器之间传递消息。HTTP 使用 TCP（而不是 UDP）作为它的支撑运输层协议。其默认工作在 TCP 协议 （80 端口），HTTP 客户机发起一个与服务器的 TCP 连接，一旦连接建立，浏览器和服务器进程就可以通过套接字接口访问 TCP。客户机从套接字接口发送 HTTP 请求报文和接收 HTTP 响应报文。类似地，服务器也是从套接字接口接收 HTTP 请求报文和发送 HTTP 响应报文。其通信内容以明文的方式发送，不通过任何方式的数据加密。当通信结束时，客户端与服务器关闭连接。
HTTPS：HTTPS（Hyper Text Transfer Protocol over Secure Socket Layer）是以安全为目标的 HTTP 协议，在 HTTP 的基础上通过传输加密和身份认证的方式保证了传输过程的安全性。其工作流程如下：
① 客户端发起一个 HTTPS 请求，并连接到服务器的**443 **端口，发送的信息主要包括自身所支持的算法列表和密钥长度等；

② 服务端将自身所支持的所有加密算法与客户端的算法列表进行对比并选择一种支持的加密算法，然后将它和其它密钥组件一同发送给客户端。

③ 服务器向客户端发送一个包含数字证书的报文，该数字证书中包含证书的颁发机构、过期时间、服务端的公钥等信息。

④ 最后服务端发送一个完成报文通知客户端 SSL 的第一阶段已经协商完成。

⑤ SSL 第一次协商完成后，客户端发送一个回应报文，报文中包含一个客户端生成的随机密码串，称为 pre_master_secre，并且该报文是经过证书中的公钥加密过的。

⑥ 紧接着客户端会发送一个报文提示服务端在此之后的报文是采用pre_master_secre 加密的。

⑦ 客户端向服务端发送一个 finish 报文，这次握手中包含第一次握手至今所有报文的整体校验值，最终协商是否完成取决于服务端能否成功解密。

⑧ 服务端同样发送与第 ⑥ 步中相同作用的报文，已让客户端进行确认，最后发送 finish 报文告诉客户端自己能够正确解密报文。
![2021_05_28_image.png](https://cdn.logseq.com/%2F1e5b0e5f-d368-4a5d-86eb-09a690ee15d7ce585b2d-6b60-494f-aa08-2a167a404ec02021_05_28_image.png?Expires=4775795754&Signature=PWftv8yPCSCzn28AlV9heeB7hIBf~lHku5W6Ige0GotyQVXUVevtC1P05YzEZfXeE93B1CC6ZD462T587NYbntlNPYTN5UnrNjoFlHrmlPXPudOkdV4XBv-JD8bBqL46OwhFyK976UQXfqfhIHyk-BDJ4g-MQ5M2LEWIQAuPVmWI3Fuua5QDFKQoEOyrdUlzVRQKnf1xYQ-EEtPq9jbTPlS1Nivmj91xXSGu9ckDUrGKzQ1Yr5UXJeT3WLr0il3nZ8TuBSweGyOVEkrwaDFX5pWd5ghfjRpeybM3xrN9YzKPlyhf-Jvy7ICoTuNdD3aVUhd3AiXKwxazKR2VzMHGOg__&Key-Pair-Id=APKAJE5CCD6X7MP6PTEA) 
当服务端和客户端的 finish 报文交换完成之后，SSL 连接就算建立完成了，之后就进行和 HTTP 相同的通信过程，唯一不同的是在 HTTP 通信过程中并不是采用明文传输，而是采用对称加密的方式，其中对称密钥已经在 SSL 的建立过程中协商好了。
## HTTPS 和 HTTP 的区别：
    HTTP 协议以明文方式发送内容，数据都是未加密的，安全性较差。HTTPS 数据传输过程是加密的，安全性较好。
    HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80 端口，后者是 443 端口。
    HTTPS 协议需要到数字认证机构（Certificate Authority, CA）申请证书，一般需要一定的费用。
    HTTP 页面响应比 HTTPS 快，主要因为 HTTP 使用 3 次握手建立连接，客户端和服务器需要握手 3 次，而 HTTPS 除了 TCP 的 3 次握手，还需要经历一个 SSL 协商过程。
## 为什么要CA:
## 防止中间人篡改公钥SPK为MPK，和客户端联系（相当于中间加了个服务器，服务器自己用SPK和服务器通信，用MPK和客户端通信）中间人没有 CA 机构的私钥；另外，数字证书中包含了服务端的域名，如果中间人掉包会出现错误的服务器域名（还是有点问题，这里掉包不能换域名吗？只有一种解释方法那就是他不知道客户端的域名，即无法解密含CA的报文），**客户端会与CA通信看看来的报文是不是没被篡改过的**
## 8.HTTP 是不保存状态的协议,如何保存用户状态？
    两种解决方案：
    ① 基于 Session 实现的会话保持：在客户端第一次向服务器发送 HTTP 请求后，服务器会创建一个 Session 对象并将客户端的身份信息以键值对的形式存储下来，然后分配一个会话标识（SessionId）给客户端，这个会话标识一般保存在客户端 Cookie 中，之后每次该浏览器发送 HTTP 请求都会带上 **Cookie 中的 SessionId 到服务器**，服务器根据会话标识就可以将之前的状态信息与会话联系起来，从而实现会话保持。
    优点：安全性高，因为状态信息保存在服务器端。
    缺点：由于大型网站往往采用的是分布式服务器，浏览器发送的 HTTP 请求一般要先通过负载均衡器才能到达具体的后台服务器，倘若同一个浏览器两次 HTTP 请求分别落在不同的服务器上时，基于 Session 的方法就不能实现会话保持了。
    **【解决方法：采用中间件，例如 Redis，我们通过将 Session 的信息存储在 Redis 中，使得每个服务器都可以访问到之前的状态信息】**
    ② 基于 Cookie 实现的会话保持：当服务器发送响应消息时，在 HTTP 响应头中设置 Set-Cookie 字段，用来存储客户端的状态信息。客户端解析出 HTTP 响应头中的字段信息，并根据其生命周期创建不同的 Cookie，这样一来每次浏览器发送 HTTP 请求的时候都会带上 Cookie 字段，从而实现状态保持。基于 Cookie 的会话保持与基于 Session 实现的会话保持最主要的区别是前者完全将会话状态信息存储在浏览器 Cookie 中。
    优点：服务器不用保存状态信息， 减轻服务器存储压力，同时便于服务端做水平拓展。
    缺点：该方式不够安全，因为状态信息存储在客户端，这意味着不能在会话中保存机密数据。除此之外，浏览器每次发起 HTTP 请求时都需要发送额外的 Cookie 到服务器端，会占用更多带宽。
## 个人总结：1.session是要配合cookie才有用的
## 2.cookie占用更多带宽是相对的，因为session只需要发送cookie中的sessionId
## 3.区别为：session是服务器给了客户端一个sessionId，说：你给我存在cookie里，以后你发送http请求给我带上这个，我查你看你是啥会话就行；
cookie是服务器响应头中给客户端一个命令（Set-Cookie字段）：你给我自己生成一个Cookie存着，以后你发http请求带上你的Cookie，通过Cookie保持会话；
## Cookie被禁用了怎么办？
若遇到 Cookie 被禁用的情况，则可以通过重写 URL 的方式将会话标识放在 URL 的参数里，也可以实现会话保持。
## **状态码**
## ![2021_05_28_image.png](https://cdn.logseq.com/%2F1e5b0e5f-d368-4a5d-86eb-09a690ee15d79679f7b3-dcb4-48f8-bf95-93e50cf566512021_05_28_image.png?Expires=4775795829&Signature=cZ6GPNqfzOkT6rOJnnF66zTX~xXaOT-iOVZCpfI8F0e50qg-9bL12eFUbWmzVS6L1z16FWp45AK~yuhn15MwHvTTA8eI4SjaA2N8U5hq1HR5gf-KzO-wK~gQcU8Rh39QW77UGOcrmVy~CztCWkUy1ezyfR5wWmVxlU3AtILt3kkT39eDlJ1CIejdYOIZk9z2hGE3166TRe7kko7bVJ9dkJcbvNqcYgPmAm-FTDP1ReQNaD9WZiRadm2dvCDEWJLMm~eyWiMGQId~-zh2Bx6~V6kXVTAABX7uKk3Q3RjKw8Uh2OiK-mpo0KHMJnNayK7YggLdEVLtYlioNjqQIPZy~A__&Key-Pair-Id=APKAJE5CCD6X7MP6PTEA)
## 其他状态码： [[状态码大全]]
## 状态码 301 和 302 的区别？

301：永久移动。请求的资源已被永久的移动到新的URI，旧的地址已经被永久的删除了。返回信息会包括新的URI，浏览器会自动定向到新的URI。**今后新的请求都应使用新的URI代替**。

302：临时移动。与301类似，客户端拿到服务端的响应消息后会跳转到一个新的 URL 地址。但资源只是临时被移动，旧的地址还在，**客户端应继续使用原有URI**。
## HTTP/1.1 和 HTTP/1.0 的区别:
    1.缓存处理：在 HTTP/1.0 中主要使用 header 里的 if-modified-Since, Expries 来做缓存判断的标准。而 HTTP/1.1 请求头中添加了更多与缓存相关的字段，从而支持更为灵活的缓存策略，例如 Entity-tag, If-Unmodified-Since, If-Match, If-None-Match 等可供选择的缓存头来控制缓存策略。
    2.节约带宽： 当客户端请求某个资源时，HTTP/1.0 默认将该资源相关的整个对象传送给请求方，但很多时候可能客户端并不需要对象的所有信息。而在 HTTP/1.1 的请求头中引入了 range 头域，它允许只请求部分资源，其使得开发者可以多线程请求某一资源，从而充分的利用带宽资源，实现高效并发。
    3.错误通知的管理：HTTP/1.1 在 1.0 的基础上新增了 24 个错误状态响应码，例如 414 表示客户端请求中所包含的 URL 地址太长，以至于服务器无法处理；410 表示所请求的资源已经被永久删除。
    4.Host 请求头：早期 HTTP/1.0 中认为每台服务器都绑定一个唯一的 IP 地址并提供单一的服务，请求消息中的 URL 并没有传递主机名。而随着虚拟主机的出现，一台物理服务器上可以存在多个虚拟主机，并且它们共享同一个 IP 地址。为了支持虚拟主机，HTTP/1.1 中添加了 host 请求头，请求消息和响应消息中应声明这个字段，若请求消息中缺少该字段时服务端会响应一个 404 错误状态码。
    5.长连接：HTTP/1.0 默认浏览器和服务器之间保持短暂连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接，服务器完成后立即断开 TCP 连接。HTTP/1.1 默认使用的是持久连接，其支持在同一个 TCP 请求中传送多个 HTTP 请求和响应。此之前的 HTTP 版本的默认连接都是使用非持久连接，如果想要在旧版本的 HTTP 协议上维持持久连接，则需要指定 Connection 的首部字段的值为 Keep-Alive。
## 总结：还（缓存处理）贷（节约带宽）？错（错误码（24））！长（长连接）投（请求头）；这个口诀告诫自己拒绝校园贷，学会长线投资赚钱（硬气）；
## **HTTP/1.X 和 HTTP/2.0 的区别**
## 相比于 HTTP/1.X 的文本（字符串）传送， HTTP/2.0 采用二进制传送。客户端和服务器传输数据时把数据分成帧，帧组成了数据流，流具有流 ID 标识和优先级，通过优先级以及流依赖能够一定程度上解决关键请求被阻塞的问题。
HTTP/2.0 支持多路复用。因为流 ID 的存在， 通过同一个 HTTP 请求可以实现多个 HTTP 请求传输，客户端和服务器可以通过流 ID 来标识究竟是哪个流从而定位到是哪个 HTTP 请求。
HTTP/2.0 头部压缩。HTTP/2.0 通过 gzip 和 compress 压缩头部然后再发送，同时通信双方会维护一张头信息表，所有字段都记录在这张表中，在每次 HTTP 传输时只需要传头字段在表中的索引即可，大大减小了重传次数和数据量。
HTTP/2.0 支持服务器推送。 服务器在客户端未经请求许可的情况下，可预先向客户端推送需要的内容，客户端在退出服务时可通过发送复位相关的请求来取消服务端的推送。
## HTTP3:(后面有空的话看下)：
## HTTP/2 存在的问题：
我们知道，传统 Web 平台的数据传输都基于 TCP 协议，而 TCP 协议在创建连接之前不可避免的需要三次握手，如果需要提高数据交互的安全性，即增加传输层安全协议（TLS），还会增加更多的握手次数。 HTTP 从 1.0 到 2.0，其传输层都是基于 TCP 协议的。即使是带来巨大性能提升的 HTTP/2，也无法完全解决 TCP 协议存在的固有问题（慢启动，拥塞窗口尺寸的设置等）。此外，HTTP/2 多路复用只是减少了连接数，其队头的拥塞问题并没有完全解决，倘若 TCP 丢包率过大，则 HTTP/2 的表现将不如 HTTP/1.1。
## QUIC 协议

QUIC（Quick UDP Internet Connections），直译为快速 UDP 网络连接，是谷歌制定的一种基于 UDP 的低延迟传输协议。其主要目的是解决采用传输层 TCP 协议存在的问题，同时满足传输层和应用层对多连接、低延迟等的需求。该协议融合了 TCP, TLS, HTTP/2 等协议的特性，并基于 UDP传输。该协议带来的主要提升有：

1.低延迟连接。当客户端第一次连接服务器时，QUIC 只需要 1 RTT（Round-Trid Time）延迟就可以建立安全可靠的连接（采用 TLS 1.3 版本），相比于 TCP + TLS 的 3 次 RTT 要更加快捷。之后，客户端可以在本地缓存加密的认证信息，当再次与服务器建立连接时可以实现 0 RTT 的连接建立延迟。

2.QUIC 复用了 HTTP/2 协议的多路复用功能，由于 QUIC 基于 UDP，所以也避免了 HTTP/2存在的队头阻塞问题。

3.基于 UDP 协议的 QUIC 运行在用户域而不是系统内核，这使得 QUIC 协议可以快速的更新和部署，从而很好地解决了 TPC 协议部署及更新的困难。

4.QUIC 的报文是经过加密和认证的，除了少量的报文，其它所有的 QUIC 报文头部都经过了认证，报文主体经过了加密。只要有攻击者篡改 QUIC 报文，接收端都能及时发现。

具有向前纠错机制，每个数据包携带了除了本身内容外的部分其他数据包的内容，使得在出现少量丢包的情况下，尽量地减少其它包的重传次数，其通过牺牲单个包所携带的有效数据大小换来更少的重传次数，这在丢包数量较小的场景下能够带来一定程度的性能提升。
HTTP/3 是在 QUIC 基础上发展起来的，其底层使用 UDP 进行数据传输，上层仍然使用 HTTP/2。在 UDP 与 HTTP/2 之间存在一个 QUIC 层，其中 TLS 加密过程在该层进行处理。HTTP/3 主要有以下几个特点：
① 使用 UDP 作为传输层进行通信；
② 在 UDP 之上的 QUIC 协议保证了 HTTP/3 的安全性。QUIC 在建立连接的过程中就完成了 TLS 加密握手；
③ 建立连接快，正常只需要 1 RTT 即可建立连接。如果有缓存之前的会话信息，则直接验证和建立连接，此过程 0 RTT。建立连接时，也可以带有少量业务数据；
④ 不和具体底层连接绑定，QUIC 为每个连接的两端分别分配了一个唯一 ID，上层连接只认这对逻辑 ID。网络切换或者断连时，只需要继续发送数据包即可完成连接的建立；
⑤ 使用 QPACK 进行头部压缩，因为 在 HTTP/2 中的 HPACK 要求传输过程有序，这会导致队头阻塞，而 QPACK 不存在这个问题。
最后我们使用一张图来清晰的表示出 HTTP 协议的发展变化：
## ![2021_05_29_image.png](https://cdn.logseq.com/%2F1e5b0e5f-d368-4a5d-86eb-09a690ee15d7b1b2c75e-ebb6-467c-8cab-4fa48177509e2021_05_29_image.png?Expires=4775896159&Signature=N2Ae9DQgUMiDxnhYvDgTHpGA7YX~cpLRM58JQgqkHmH3R95PywxOI~6udkARek3pRmDbFc13mH~TFrJCRgrwYSpX6UwqPBCqC2PHnlpUElm-r7qBjjIV1TFBd0QCwKEZeZFg1Ylu5saLve9qYeCkUo56EyapRh24Recqf4eY6orOGxd7DWRoCxq3fYC6ivkPT80rltvgp55VvCI1gQ8llbaD9E95Bqu5d2hx2PzjQpymR0UKB-ogb3tHkLyxzTwrhDxsF2tSnxRPuHM6iapPLKY~Y0UHBP8JNEoQHUxztIFiQ4VPJ8dxCrTmDcU787tviXDGErl66twPBZXw~FCmkg__&Key-Pair-Id=APKAJE5CCD6X7MP6PTEA)
## **DNS:**
## DNS（Domain Name System）是域名系统的英文缩写，是一种组织成域层次结构的计算机和网络服务命名系统，用于 TCP/IP 网络。
## DNS 的作用
通常我们有两种方式识别主机：通过主机名或者 IP 地址。人们喜欢便于记忆的主机名表示，而路由器则喜欢定长的、有着层次结构的 IP 地址。为了满足这些不同的偏好，我们就需要一种能够进行主机名到 IP 地址转换的目录服务，**域名系统作为将域名和 IP 地址相互映射的一个分布式数据库**，能够使人更方便地访问互联网。
## DNS 采用了分布式的设计方案，其域名空间采用一种树形的层次结构：
## ![2021_05_29_image.png](https://cdn.logseq.com/%2F1e5b0e5f-d368-4a5d-86eb-09a690ee15d7ee6ae798-5264-4d98-be3e-eb20ce84a1b42021_05_29_image.png?Expires=4775896304&Signature=nDmHwz4sRoL1Pp88~mi2SSzAFtbQvFRyDov7xQyi7Bx2vrWIMHKvCJJDc7z5XTMtdlzyLXlcFjMhN~-0Okkiz---eKuRLR2W6PWpKW0fO-X8aoED1zPeErj7r2nbx0BG1j98Bn5rUSlmRPGBUY9j3CtYzuvQCF8OQAxVg0NgXnrVi~GqKKwpPuTVcUFPF5E6Wf6X3lOF0tklXVXeJKjdU4~M-ZLEZSHiMU4JJwwGe-BThxWEjJyCtf~TiSDQl~DwsYd20rWdTW47Kj-XtGZKp2UqRnu-O-hUWJbZxFJWrxzbNDR21hqtYWka0qz5daN8R53-PqzTeeGbd5d95XhLhA__&Key-Pair-Id=APKAJE5CCD6X7MP6PTEA)
## DNS 服务器的部分层次结构为：从上到下依次为根域名服务器、顶级域名服务器和权威域名服务器。其实**根域名服务器**在因特网上有**13个**，大部分位于北美洲。第二层为**顶级域服务器**，这些服务器负责顶级域名（如 **com、org、net、edu**）和所有国家的顶级域名（如**uk、fr、ca 和 jp**）。在第三层为**权威 DNS 服务器**，因特网上具有公共可访问主机（例如 Web 服务器和邮件服务器）的每个组织机构必须提供公共可访问的 DNS 记录，这些记录由组织机构的权威 DNS 服务器负责保存，这些记录将这些主机的名称映射为 IP 地址。
除此之外，还有一类重要的 DNS 服务器，叫做**本地 DNS 服务器**。本地 DNS 服务器严格来说不在 DNS 服务器的层次结构中，但它对 DNS 层次结构是很重要的。一般来说，每个**网络服务提供商（ISP）** 都有一台本地 DNS 服务器。当**主机与某个 ISP 相连时**，该 **ISP 提供一台主机的 IP 地址，该主机具有一台或多台其本地 DNS 服务器的 IP 地址**。主机的本地 DNS 服务器通常和主机距离较近，当**主机发起 DNS 请求时，该请求被发送到本地 DNS 服务器，它起着代理的作用，并将该请求转发到 DNS 服务器层次结构中。**
## 我们以一个例子来了解 DNS 的工作原理，假设主机 A（IP 地址为 abc.xyz.edu） 想知道主机 B 的 IP 地址 （**def.mn.edu**），如下图所示，**主机 A 首先向它的本地 DNS 服务器发送一个 DNS 查询报文**。该查询报文含有被转换的主机名 def.mn.edu。本地 DNS 服务器将该报文转发到**根 DNS 服务器**，根 DNS 服务器注意到查询的 IP 地址前缀为 edu 后向**本地 DNS 服务器返回负责 edu 的顶级域名服务器的 IP 地址列表**。该**本地 DNS 服务器则再次向这些 顶级域名服务器发送查询报文**。该**顶级域名服务器**注意到 mn.edu 的前缀，并**用权威域名服务器的 IP 地址进行响应。**通常情况下，顶级域名服务器并不总是知道每台主机的权威 DNS 服务器的 IP 地址（可能是权威DNS服务器太多了），而只知道中间的某个服务器，该中间 DNS 服务器依次能找到用于相应主机的 IP 地址，我们假设中间经历了权威服务器 ① 和 ②，最后找到了负责 def.mn.edu 的权威 DNS 服务器 ③，之后，本地 DNS 服务器直接向该服务器发送查询报文从而获得主机 B 的IP 地址。
##
